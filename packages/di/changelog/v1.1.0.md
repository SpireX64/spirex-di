# SpireX/DI — v1.1.0 Change Log

Version 1.1.0 introduces a set of improvements aimed at making dependency management more flexible, type-safe, and observable.
The update expands the Middleware API, enhances builder introspection, strengthens factoryOf, and improves scoped bindings and metadata typing.

Together, these changes make **SpireX/DI** easier to extend and safer to use in large or highly modular applications.

## Middleware Enhancements

### `onPreBuild` Hook
A new `onPreBuild` hook is executed **before container build starts**.
It allows middleware to validate builder state, inspect existing bindings, or register additional bindings required for middleware operation.

This hook is especially useful for enforcing constraints or preparing internal services before the container is finalized.

```js
builder.use({
    onPreBuild(builder) {
        builder.findEntry(entry => entry.type === 'config');
        builder.bindInstance('internalLogger', loggerInstance);
        builder.hasModule('core');
    },
});
```

### `onPostBuild` Hook
The new `onPostBuild` hook runs after the container has been successfully built and all singletons are activated.

It enables final verification and eager configuration of services before the container is exposed to the application.

```js
builder.use({
    onPostBuild(container) {
        container.maybe('service');
        container.scope('ui').get('sharedStore');
        container.get('logger').time('di-ready');
    },
});
```
This hook is ideal for health checks, warm-up logic, or instrumentation.

### Builder Access in `onBind`
The `onBind` hook now receives a reference to the **current builder**.

This allows bindings to react dynamically to other bindings, enabling advanced patterns such as grouping, aliasing, or conditional registration.

```js
builder.use({
    onBind(entry, origin, builder) {
        if (entry.type === 'cmdHandler' && entry.name) {
            builder.bindAlias('cmdHandler', entry.type, {
                originName: entry.name,
                ifConflict: 'append',
            });
        }
        return entry;
    },
});
```

### Activation Stack in `onActivated`
The `onActivated` hook now provides an **activation stack**, showing the full dependency chain that caused an instance to be created.

This makes it possible to understand who requested a dependency and why it was activated.

```js
builder.use({
    onActivated(entry, instance, scope, stack) {
        // Example stack:
        // ['viewModel', 'interceptor', 'repo', 'http']
        // The current type is the last element.
        // The initiator of activation is the first element.
    },
});
```
This feature enables advanced diagnostics, conditional decoration, and tracing.

### Typed Middleware with `TypeMap`
Middleware can now define its own `TypeMap` and **inherit** the container’s `TypeMap`.

This allows middleware to:
- Register new types without splitting logic into a module;
- Access container types with full TypeScript type checking;
- Use `onUse` and `onPreBuild` hooks with strong typing.


```ts
diBuilder<{ service: MyService }>().use({
    onUse(builder) {
        // builder:
        // IContainerBuilder<{ service: MyService }>
        builder.findEntry('service') 
    }
})
```
This significantly improves middleware authoring ergonomics and safety.


## Scoped Factory Bindings
Factory bindings can now be declared as their **own scope** using `withScope` option.

When enabled, a new scope is created **per type key**, and both the instance and its dependencies are resolved within that scope.

```ts
builder.bindFactory(
    'typeKey',
    factoryOf(MyService),
    { withScope: true },
);
```
This is useful for isolating stateful services or implementing per-feature lifetimes.

## Strongly Typed Binding Metadata

### Typed Metadata Dictionary
Binding metadata is now described using the generic type
`TTypeEntryMeta<TypeMap, TypeKey>` with values of `ITypeEntryMetaData<TypeMap, TypeKey>`.

Metadata can now:
- Reference other container types safely;
- Access the current type key;
- Fail at compile time if referenced types are renamed or missing.

```ts
function spy<TypeMap extends TTypeMapBase, T>(
    logger: keyof TypeMapFilterByType<TypeMap, ILogger>,
): ITypeEntryMeta<TypeMap, T> {
    return {
        spy: { logger },
    };
}

builder.bindFactory('service', factoryOf(MyService), {
    meta: spy('appLogger'),
});
```
This enables metadata-driven tooling while preserving full type safety.


## Builder Inspection and Entry Search

### `find` and `findAll` Methods
The builder now provides `find` and `findAll` methods for searching type bindings using a predicate.

- `find` returns the first matching entry
- `findAll` returns all matching entries

These methods are available:
- On the builder itself
- Inside middleware hooks: `onUse`, `onBind`, `onPreBuild`

```js
builder.find(entry => entry.meta?.spy !== undefined);
builder.findAll(entry => entry.scope === 'ui');
```

## `factoryOf` Improvements

### Frozen Class Dependencies
Class dependency lists captured by `factoryOf` are now **frozen at registration time**.

This prevents accidental or malicious runtime modification of constructor dependency metadata after factory registration.

### `factoryOf` for Factory Functions
`factoryOf` now supports **plain factory functions**, reducing boilerplate for manual dependency extraction.

```js
builder.bindFactory(
    'service',
    factoryOf(
        makeService,
        ['user', 'eventBus', 'repo', 'logger'],
    ),
);

// Equivalent to:
builder.bindFactory('service', r =>
    makeService(
        r.get('user'),
        r.get('eventBus'),
        r.get('repo'),
        r.get('logger'),
    ),
);
```

### Fast-Fail Dependency Validation
Because `factoryOf` knows all dependency keys in advance, they are now **validated during container build**.

If a required dependency is missing, container construction fails immediately—similar to `bindSafeFactory`.

```ts
const container = diBuilder<{
    auth: AuthService;
    authGateway: IAuthGateway;
}>()
    .bindFactory('auth', factoryOf(AuthService))
    .build(); // Throws: 'authGateway' is not bound
```
This provides safer defaults without sacrificing performance.

## Falsy Branch Support in `when`
The `when` operator now supports an optional **falsy branch**, removing the need to define two separate conditions.
```ts
builder.when(
    condition,
    (binder) => { /* truthy branch */ },
    (binder) => { /* falsy branch */ },
);
```
This simplifies conditional binding logic and improves readability.

----------------
## Summary

**SpireX/DI v1.1.0** significantly enhances middleware extensibility, lifecycle visibility, and type safety.
Developers gain new lifecycle hooks, better diagnostics through activation stacks, and more powerful builder analysis tools.

`factoryOf` becomes safer and more expressive, while typed metadata and scoped bindings unlock advanced architectural patterns.

Overall, this release makes dependency management more predictable, observable, and maintainable in complex applications.
